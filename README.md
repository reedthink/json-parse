目标：模仿[json-tutorial](https://github.com/miloyip/json-tutorial)项目写一个json解析器  
值得注意的点：
- 测试驱动开发。这是第一次进行实践

## 其他：
`git commit --amend --no-edit   # 追加到上次commit。不会进入编辑器，直接进行提交`

## 开发日志
### 第1天（2020/4/13）
…………

### 第2天（2020/7/6）

今天重启这个项目，这次决心做完。  
今日把[json的标准文档](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)阅读了一遍，说实话，看的不是很明白。。

### 第3天（2020/7/7）

对于测试驱动开发有了进一步的了解，但是教程中简单的测试程序依然不太懂，主要是宏的部分有些复杂。
第一次接触到防御型编程这个概念，对我来说是个很新鲜的词。不过它的原理和web后台开发中的一句话很像：永远不要相信前端传回的数据，含义就是对于从前端接受的数据后端必须进行校验。不过防御型编程的概念更宽泛，粒度可以更小，每个子程序都需要对另外的子程序传过来的数据进行"防御"。

### 第4天（2020/7/12）

中间隔了几天，今天继续对代码进行注释

### 第5天（2020/7/13）

把第一课的代码完全补全了，而且加上了注释。

### 第6天（2020/7/14）
开始第二课，在第一课代码的基础上进行改进。

关于项目的cmakelists，把leptjson.c作为库进行编译，注意头文件是不需要额外处理的，编程语言已经内建了处理机制。

### 第7天（2020/7/15）
试着对代码进行重构，没有思路。参考了答案才发现可以直接对函数参数修改，虽然动了接口，但这是一个不暴露给外界的函数，因此是可以接受的。

### 第8天（2020/7/16）
终于把第二课的代码通过了所有测试，测试失败的原因居然是测试代码写错了几个地方，我真是太憨憨了。  
开始第三课--解析字符串

### 第9天（2020/7/17）
关于断言：断言是防御式编程中常用的技巧，主要是为了避免编码中出现的错误（个人粗浅理解）

在c语言中，动态管理内存，可以在代码中使用指针，然后通过其他代码控制内存。因为以前习惯使用固定数量的数组或者字符数组，所以不习惯这种动态管理方式。从这些代码可以窥到，手动管理内存真是个累活，而且很容易写出漏洞。

终于把自己埋的bug都找到了，基本上都是编码错误。因为教程中没有详细到每个函数，所以跟教程走下来之后还要debug。

还学会了使用valgrind工具来检测内存泄漏，不得不说，这是个nb的工具，c/c++开发必备。侧面反映了手动管理内存有多危险=，=

### 第10天（2020/7/18）
#### Unicode相关概念：  
- 码点：Unicode中每个字符对应的数字
- 编码单元：？？未知
- Unicode转换格式：UTF-8,UTF-16，UTF-32。前两个是可变长度编码，最后一个是不可变长度编码。
- UTF-8：编码单元是字节（8位二进制位）
- 基本多文种平面（谁把抽象的编码方式给具象化的，害我迷了半天……）
- 代理对
- 高代理项
- 低代理项

码点小于32的字符是控制字符，无法打印

对于解析器来说，json文件是以一个字符流的形式呈现的。
那么待读取的json文件（UTF-8编码），如果字符是ascii范围的，可以存储为常用的char型变量，而对于UTF-8编码的字符，解析器接受到是'\uXXXX'的编码（这够底层了），解析器对它们的处理类似于对转义字符的处理，需要设计一个新的结构来接收utf-8编码的字符。

### 第11天（2020/7/19）
使用无符号整型（unsigned）接收码点。
完成第四课。

### 第12天（2020/7/20）
开始第五课，解析数组

### 第13天（2020/7/21）
对于数组的解析，值得记录的还是内存管理。由于在完全读取数组前并不能知道数组有多大，所以只能采用动态方式处理。这里可以复用之前的手写堆栈，而数组是支持嵌套的，不过嵌套能够正确解析，不用担心。

### 第14天（2020/7/22）
完成第5课。

### 第15天（2020/7/23）
### 第16天（2020/7/24）
### 第17天（2020/7/25）
### 第18天（2020/7/25）
完成第6课。
